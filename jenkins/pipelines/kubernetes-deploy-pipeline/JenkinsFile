pipeline {
    agent {
        label 'jenkins-slave'
    }
    environment {
        PATH = "/home/jenkins-slave/.local/bin/:${env.PATH}" // Add Ansible bin directory to PATH
        SECRET_NAME = "${env.cluster_name}-jenkins-sa-kubeconf" // Define the name of your secret in AWS Secrets Manager
    }
    options {
        timeout(time: 30, unit: 'MINUTES') // Timeout for the entire pipeline
    }
    stages {
        stage('Checkout') {
            steps {
                git branch: "${env.branch_name}", credentialsId: 'github-pedro', url: params.git_url
            }
        }

        stage('Run TFLint') {
            steps {
                dir('terraform/environments/stage') {
                    script {
                        // Run tflint and save results
                        sh 'tflint --format=json > tflint-results.json'

                        // Read and parse the JSON output
                        def tflintResults = readJSON file: 'tflint-results.json'

                        // Determine if there are any errors
                        if (tflintResults.errors.size() > 0) {
                            error("TFLint reported errors.")
                        }
                    }

                }
            }
        }

        stage('Run Checkov') {
            steps {
                dir('terraform/environments/stage') {
                    script {
                        try {
                            // Run checkov and save results
                            sh 'checkov -d . --quiet --framework terraform --output json > checkov-results.json'

                            // Read and parse the JSON output
                            def checkovResults = readJSON file: 'checkov-results.json'

                            // Check for failed checks
                            if (checkovResults.results.failed_checks) {
                                // Iterate over failed checks and handle them
                                for (failedCheck in json.results.failed_checks) {
                                    // Print out information about each failed check
//                                     echo "Failed Check ID: ${failedCheck.check_id}"
//                                     echo "Failed Check Name: ${failedCheck.check_name}"
//                                     echo "File Path: ${failedCheck.file_path}"
//                                     echo "File Line Range: ${failedCheck.file_line_range}"
                                    // You can add further actions here, such as failing the build or taking corrective actions
                                }
                                archiveArtifacts artifacts: 'checkov-results.json', onlyIfSuccessful: false
                                // Fail the build if there are failed checks
                                error("Checkov reported failed checks.")
                            }
                        } catch (Exception e) {
                            // If checkov command fails, print error message but continue execution
                            archiveArtifacts artifacts: 'checkov-results.json', onlyIfSuccessful: false
                            error("Error running checkov: ${e.message}")

                        }
                    }
                }
            }
        }



        stage('Run TFSec') {
            steps {
                dir('terraform/environments/stage') {
                    script {
                        // Run tfsec and output results to a file
                        sh 'tfsec . --format=json --soft-fail > tfsec-results.json'

                        // Read the tfsec results file
                        def tfsecResults = readJSON file: 'tfsec-results.json'

                        // Check for critical results
                        boolean hasCriticals = tfsecResults.results.any { result ->
                            result.severity == "CRITICAL"
                        }

                        // Fail the pipeline if there are critical alerts
                        if (hasCriticals) {
                            error("Critical alerts found by tfsec.")
                        }
                    }
                    // Archive the tfsec-results.json file immediately after it's created

                }
            }
        }

        stage('Terraform init,plan,apply') {
            steps {
                dir('terraform/environments/stage') {
                    script {
                        withCredentials([[
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: 'jenkins-automate-user', // Use the ID you assigned in Jenkins Credentials Store
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]]) {
                            sh 'terraform init'
                            sh 'terraform validate'
                            sh 'terraform plan -out=plan.out'
                            input message: 'Do you want to apply the Terraform plan?', ok: 'Yes'
                            sh 'terraform apply plan.out'
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            // Archive artifacts outside of the stage
            //archiveArtifacts artifacts: 'terraform/environments/stage/checkov-results.json', onlyIfSuccessful: false
            archiveArtifacts artifacts: 'terraform/environments/stage/tflint-results.json', onlyIfSuccessful: false
            archiveArtifacts artifacts: 'terraform/environments/stage/tfsec-results.json', onlyIfSuccessful: false
            //cleanWs() // Cleanup
        }
    }
}




//         stage('Retrieve Kubeconfig from AWS Secrets Manager') {
//             steps {
//                 script {
//                     // Use the credentials binding plugin to securely inject AWS credentials
//                     withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'jenkins-ecr-access', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
//                         // Retrieve the kubeconfig from AWS Secrets Manager
//                         sh '''
//                         aws secretsmanager get-secret-value --region us-east-1 --secret-id ${SECRET_NAME} --query SecretString --output text > kubeconfig
//                         '''
//
//                         // Set the KUBECONFIG environment variable for subsequent steps
//                         env.KUBECONFIG = "${WORKSPACE}/kubeconfig"
//                     }
//                 }
//             }
//         }
//
//         stage('Install Istio') {
//             steps {
//                 sh """
//                 ${env.ansible_dir}/ansible-playbook playbooks/istio-install.yml -vvv
//                 """
//             }
//         }
//     }
//     post {
//         always {
//             // Cleanup
//             cleanWs()
//         }
//     }
// }
